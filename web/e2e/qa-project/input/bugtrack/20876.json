{"id":20876, "kind":"Bug", "createdAt":"2013-02-21T10:11:23.366421-08:00", "status":"Closed", "title":"SQL View: Unable to formulate wildcard search using the MATCH operator", "category":"SQL", "severity":"Major", "priority":{"level":"5", "title":""}, "submittedBy":{"username":"gfurbush", "name":"Gordon Furbush ", "email":"gfurbush@marklogic.com"}, "assignTo":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}, "description":"I'm having problems coming up with a workable query to return all of the employees whose name starts with a particular letter.\r\n\r\nThis is the view:\r\n\r\nmlsql=> describe employees;\r\n schema |   table   | cid |    name    | type | notnull | dflt_value | pk\r\n--------+-----------+-----+------------+------+---------+------------+--\r\n--------+-----------+-----+------------+------+---------+------------+--\r\n main   | employees |   0 | employeeid | INT  |       1 |            |  0\r\n main   | employees |   1 | firstname  | TEXT |       1 |            |  0\r\n main   | employees |   2 | lastname   | TEXT |       1 |            |  0\r\n(3 rows)\r\n\r\nThis is the contents:\r\n\r\nmlsql=> select * from employees;\r\n employeeid | firstname | lastname\r\n------------+-----------+----------\r\n          1 | John      | Widget\r\n          2 | Jane      | Lead\r\n          3 | Steve     | Manager\r\n          4 | Debbie    | Goodall\r\n(4 rows)\r\n\r\nNone of the following queries work:\r\n\r\nmlsql=> select * from employees where firstname match 'J*'; \r\nmlsql=> select * from employees where employees match \"firstname:J*\"; \r\nmlsql=> select * from employees where firstname match '\"[J]*\"';\r\n\r\nAll of these return:\r\n\r\n employeeid | firstname | lastname\r\n------------+-----------+----------\r\n(0 rows)\r\n\r\nMary, per your suggestion, I tried double quotes without joy:\r\n\r\nmlsql=> => select * from employees where firstname match '\"J*\"';\r\nERROR:  SQL-ERROR: SQL error: sqlite3-step() failed due to error 'near \"=\": syntax error'\r\n\r\nmlsql=> => select * from employees where firstname match \"'J*'\";\r\nERROR:  SQL-ERROR: SQL error: sqlite3-step() failed due to error 'near \"=\": syntax error'\r\n\r\n", "samplequery":"", "sampledata":"", "version":"7.0-nightly", "tofixin":"7.0-ea2", "fixedin":"N/A", "platform":"linux(64-bit)", "memory":"", "processors":"", "note":"", "subscribers":[{"username":"gfurbush", "name":"Gordon Furbush ", "email":"gfurbush@marklogic.com"}, {"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}], "attachments":[], "relationships":[{"type":"", "to":""}], "clones":[], "cloneOf":"", "support":{"headline":"", "supportDescription":"", "publishStatus":"Not Ready", "tickets":[], "customerImpact":{"level":"N/A", "title":""}, "workaround":""}, "tags":["SQL", "gfurbush"], "changeHistory":[{"time":"2013-02-21T10:11:23.366421-08:00", "updatedBy":{"username":"gfurbush", "name":"Gordon Furbush ", "email":"gfurbush@marklogic.com"}, "change":{"assignTo":{"from":{"username":"gfurbush", "name":"Gordon Furbush ", "email":"gfurbush@marklogic.com"}, "to":{"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}}}, "files":[], "show":true}, {"time":"2013-02-21T12:14:07.922415-08:00", "updatedBy":{"username":"dsokolsky", "name":"Danny Sokolsky", "email":"dsokolsky@marklogic.com"}, "change":{"tofixin":{"from":"", "to":"7.0-ea2"}}, "files":[], "show":true}, {"time":"2013-02-21T12:51:46.392877-08:00", "updatedBy":{"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}, "change":{"status":{"from":"", "to":"Closed"}, "assignTo":{"from":{"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}, "to":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}}}, "files":[], "show":true, "comment":"On further review, this is not a bug; it is a consequence of unfiltered search.\r\nThe proper way to formulate the query is\r\nselect * from employees where firstname match 'J*';\r\nor\r\nselect * from employees where employees match 'firstname:J*';\r\n\r\nThe double quotes also work, although they aren't necessary:\r\nselect * from employees where firstname match '\"J*\"';\r\n\r\nYou can explicitly make these wildcarded:\r\nselect * from employees where firstname match 'J*[wildcarded]';\r\n\r\nWhich, in absence of any wildcard indexes, will return everything.\r\n\r\nI see these working correctly. \r\n\r\nHowever, I have wildcards enabled and a word lexicon, which you would need to have if you expected these to work. If you do not have any wildcard indexes enabled, then you are seeing this as a literal query for the word \"J\" and the punctuation \"*\", which returns (correctly) nothing."}, {"time":"2013-02-21T12:51:46.392877-08:00", "updatedBy":{"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}, "change":{"assignTo":{"from":{"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}, "to":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}}}, "files":[], "show":true}], "updatedAt":"2013-02-21T12:51:46.392877-08:00", "closedAt":"2013-02-21T12:51:46.392877-08:00", "closedBy":{"username":"mary", "name":"Mary Holstege", "email":"mary@cerisent.com"}, "renderDescriptionAs":"normal"}