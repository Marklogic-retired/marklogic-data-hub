{"id":2067, "kind":"RFE", "createdAt":"2005-08-10T06:52:14.929623-07:00", "status":"Verify", "title":"Support GROUP BY in XQuery", "category":"xdmp", "severity":"Minor", "priority":{"level":"5", "title":""}, "submittedBy":{"username":"michael", "name":"Michael Blakeley", "email":"michael.blakeley@marklogic.com"}, "assignTo":{"username":"sbuxton", "name":"Stephen Buxton", "email":"stephen.buxton@marklogic.com"}, "description":"BEA has a nice-looking proposal for group-by, having, and outer-joins.\r\n\r\nhttp://www.idealliance.org/proceedings/xml04/papers/229/XQueryExtensionsFinal.html", "samplequery":"", "sampledata":"", "version":"N/A", "tofixin":"N/A", "fixedin":"", "platform":"all", "memory":"", "processors":"", "note":"", "subscribers":[{"username":"michael", "name":"Michael Blakeley", "email":"michael.blakeley@marklogic.com"}, {"username":"sbuxton", "name":"Stephen Buxton", "email":"stephen.buxton@marklogic.com"}], "attachments":[], "includeInTaskList":false, "proceduralTasks":{"Requirements Task":[], "Functional Specification Task":[], "Test Specification Task":[], "Test Automation Task":[], "Documentation Task":[]}, "subTasks":[], "tags":["xdmp", "michael"], "changeHistory":[{"time":"2005-08-10T10:57:10.521833-07:00", "updatedBy":{"username":"dsokolsky", "name":"Danny Sokolsky", "email":"dsokolsky@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"Here is a link to the BEA doc for their GROUP BY extention.  They have implemented this and are currently shipping it in there latest \"AquaLogic Data Services Platform\" (formerly known as Liquid Data).\n\nhttp://e-docs.bea.com/liquiddata/docs85/xquery/extensions.html#1087388"}, {"time":"2006-03-12T05:15:56.307299-08:00", "updatedBy":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "change":{"status":{"from":"", "to":"Verify"}, "assignTo":{"from":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "to":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}}}, "files":[], "show":true, "comment":"verify"}, {"time":"2006-04-06T15:06:52.972642-07:00", "updatedBy":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "change":{"assignTo":{"from":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "to":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}}}, "files":[], "show":true}, {"time":"2007-12-19T05:48:48.00652-08:00", "updatedBy":{"username":"jclippinger", "name":"James Clippinger", "email":"jclippinger@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"Customers who have asked about better group-by support during engagements or training:\n\nAIP\nNEJM\nU. of Toronto\n\nAIP, in particular, ran into major problems trying to do a group-by that encompassed the whole database.  We eventually resolved that by building up groups in memory using xdmp:set() and xdmp:quote() and then unquoting the nodes for output at the end.  While this worked, it was a very un-XQuery-like approach to the problem and is not something AIP could have done without PS help.  Having a group-by builtin that leverages the range indexes would have avoided a lot of trouble."}, {"time":"2007-12-19T08:25:01.045438-08:00", "updatedBy":{"username":"michael", "name":"Michael Blakeley", "email":"michael.blakeley@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"This came up in class this week, too (question from our partners at HTC, Inc). I think the 4.0 addition of hashmaps will allow a more elegant approach than xdmp:set does."}, {"time":"2008-10-13T19:05:14.266309-07:00", "updatedBy":{"username":"michael", "name":"Michael Blakeley", "email":"michael.blakeley@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"This functionality is a requirement for a Boeing deal that Ajay and I are working on. I'm going to try to fake it in-memory with 4.0 hashmaps."}, {"time":"2008-12-15T16:21:49.643257-08:00", "updatedBy":{"username":"michael", "name":"Michael Blakeley", "email":"michael.blakeley@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"Here's an example of this technique, using Medline content. I don't know if it's fully optimized, but it did pretty well in my testing. Hopefully it can be adapted as needed.\n\nlet $groups := map:map()\nlet $do :=\n  for $mc in cts:search( /MedlineCitation, cts:element-word-query(xs:QName('ArticleTitle'), 'Australia') )\n  let $key as xs:string := $mc/MedlineJournalInfo/Country\n  let $value := map:get($groups, $key)\n  return map:put( $groups, $key, if ($value) then 1 + $value else 1 )\nfor $key in map:keys($groups)\nlet $value := map:get($groups, $key)\norder by $value descending, $key\nreturn text { $key, $value } "}, {"time":"2009-01-03T08:56:54.171961-08:00", "updatedBy":{"username":"sbuxton", "name":"Stephen Buxton", "email":"stephen.buxton@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"We should consider this for inclusion in 4.2 - hopefully there will be some clear progress in XQuery 1.1 by then."}, {"time":"2015-03-20T16:11:55.686349-07:00", "updatedBy":{"username":"gvaidees", "name":"Ganesh Vaideeswaran", "email":"Ganesh.Vaideeswaran@marklogic.com"}, "change":{"assignTo":{"from":{"username":"gvaidees", "name":"Ganesh Vaideeswaran", "email":"Ganesh.Vaideeswaran@marklogic.com"}, "to":{"username":"sbuxton", "name":"Stephen Buxton", "email":"stephen.buxton@marklogic.com"}}}, "files":[], "show":true}], "updatedAt":"2015-03-20T16:11:55.686349-07:00"}