{"id":20427, "kind":"Bug", "createdAt":"2013-01-10T12:16:38.891962-08:00", "status":"Closed", "title":"FLWOR over search results does not iterate over all values", "category":"XQuery", "severity":"Critical", "priority":{"level":"5", "title":""}, "submittedBy":{"username":"dfeldman", "name":"Damon Feldman", "email":"dfeldman@marklogic.com"}, "assignTo":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}, "description":"The query below should return four strings, but only returns 2. When the search is across a larger corpus with 500 matches, it also returns 2 results:\r\n\r\n \r\n ( xdmp:document-insert(\"/foo1.xml\", <foo>all in the family</foo>),\r\n   xdmp:document-insert(\"/foo2.xml\", <foo>influenza can be transmitted in a family</foo>),\r\n   xdmp:document-insert(\"/foo3.xml\", <foo>family thereapy may be appropriate</foo>),\r\n   xdmp:document-insert(\"/foo4.xml\", <foo>discuss this issue with your family soon</foo>)\r\n   )\r\n\r\n;\r\n xdmp:version()\r\n; \r\ndeclare namespace dist = \"distance\";\r\n\r\ndeclare function dist:words-around() {\r\n  (: if we remove the FLWOR and just return \"words around stub\", then it works\r\n     if the let is something other than empty sequence, then it works:)\r\n  let $log := xdmp:log(\"in words-around. expect w a priv shortly\")\r\n  return \"WORDS-AROUND-STUB\"\r\n};\r\n\r\nlet $kwd := \"family\"\r\nfor $ht in cts:search(/foo, $kwd)[1 to 9]\r\nreturn dist:words-around() (: if we directly reurn a string, rather than a function that returns a string, then this works :)", "samplequery":"The original, more complex query that evinced the bug is:\r\n\r\n\r\ndeclare namespace dist = \"distance\";\r\n\r\ndeclare option xdmp:mapping \"false\";\r\n\r\ndeclare variable $HIGHLIGH-OPTIMIZE := true();\r\ndeclare variable $ASSUME-MAX-CHARS-PER-WORD := 5;\r\n\r\ndeclare variable $stops as map:map := \r\n  let $m := map:map()\r\n  let $add := \r\n    for $w in (\"p\", \"ul\", \"li\", \"br\", \"a\", \"about\", \"above\", \"above\", \"across\", \"after\", \"afterwards\", \"again\", \"against\", \"all\", \"almost\", \"alone\", \"along\", \"already\", \"also\",\"although\",\"always\",\"am\",\"among\", \"amongst\", \"amoungst\", \"amount\",  \"an\", \"and\", \"another\", \"any\",\"anyhow\",\"anyone\",\"anything\",\"anyway\", \"anywhere\", \"are\", \"around\", \"as\",  \"at\", \"back\",\"be\",\"became\", \"because\",\"become\",\"becomes\", \"becoming\", \"been\", \"before\", \"beforehand\", \"behind\", \"being\", \"below\", \"beside\", \"besides\", \"between\", \"beyond\", \"bill\", \"both\", \"bottom\",\"but\", \"by\", \"call\", \"can\", \"cannot\", \"cant\", \"co\", \"con\", \"could\", \"couldnt\", \"cry\", \"de\", \"describe\", \"detail\", \"do\", \"done\", \"down\", \"due\", \"during\", \"each\", \"eg\", \"eight\", \"either\", \"eleven\",\"else\", \"elsewhere\", \"empty\", \"enough\", \"etc\", \"even\", \"ever\", \"every\", \"everyone\", \"everything\", \"everywhere\", \"except\", \"few\", \"fifteen\", \"fify\", \"fill\", \"find\", \"fire\", \"first\", \"five\", \"for\", \"former\", \"formerly\", \"forty\", \"found\", \"four\", \"from\", \"front\", \"full\", \"further\", \"get\", \"give\", \"go\", \"had\", \"has\", \"hasnt\", \"have\", \"he\", \"hence\", \"her\", \"here\", \"hereafter\", \"hereby\", \"herein\", \"hereupon\", \"hers\", \"herself\", \"him\", \"himself\", \"his\", \"how\", \"however\", \"hundred\", \"ie\", \"if\", \"in\", \"inc\", \"indeed\", \"interest\", \"into\", \"is\", \"it\", \"its\", \"itself\", \"keep\", \"last\", \"latter\", \"latterly\", \"least\", \"less\", \"ltd\", \"made\", \"many\", \"may\", \"me\", \"meanwhile\", \"might\", \"mill\", \"mine\", \"more\", \"moreover\", \"most\", \"mostly\", \"move\", \"much\", \"must\", \"my\", \"myself\", \"name\", \"namely\", \"neither\", \"never\", \"nevertheless\", \"next\", \"nine\", \"no\", \"nobody\", \"none\", \"noone\", \"nor\", \"not\", \"nothing\", \"now\", \"nowhere\", \"of\", \"off\", \"often\", \"on\", \"once\", \"one\", \"only\", \"onto\", \"or\", \"other\", \"others\", \"otherwise\", \"our\", \"ours\", \"ourselves\", \"out\", \"over\", \"own\",\"part\", \"per\", \"perhaps\", \"please\", \"put\", \"rather\", \"re\", \"same\", \"see\", \"seem\", \"seemed\", \"seeming\", \"seems\", \"serious\", \"several\", \"she\", \"should\", \"show\", \"side\", \"since\", \"sincere\", \"six\", \"sixty\", \"so\", \"some\", \"somehow\", \"someone\", \"something\", \"sometime\", \"sometimes\", \"somewhere\", \"still\", \"such\", \"system\", \"take\", \"ten\", \"than\", \"that\", \"the\", \"their\", \"them\", \"themselves\", \"then\", \"thence\", \"there\", \"thereafter\", \"thereby\", \"therefore\", \"therein\", \"thereupon\", \"these\", \"they\", \"thickv\", \"thin\", \"third\", \"this\", \"those\", \"though\", \"three\", \"through\", \"throughout\", \"thru\", \"thus\", \"to\", \"together\", \"too\", \"top\", \"toward\", \"towards\", \"twelve\", \"twenty\", \"two\", \"un\", \"under\", \"until\", \"up\", \"upon\", \"us\", \"very\", \"via\", \"was\", \"we\", \"well\", \"were\", \"what\", \"whatever\", \"when\", \"whence\", \"whenever\", \"where\", \"whereafter\", \"whereas\", \"whereby\", \"wherein\", \"whereupon\", \"wherever\", \"whether\", \"which\", \"while\", \"whither\", \"who\", \"whoever\", \"whole\", \"whom\", \"whose\", \"why\", \"will\", \"with\", \"within\", \"without\", \"would\", \"yet\", \"you\", \"your\", \"yours\", \"yourself\", \"yourselves\", \"the\")\r\n    return map:put($m, $w, true())\r\n  return $m;   \r\n\r\ndeclare function dist:words-around-private($text-elem as element(), $kwd as xs:string, $distance as xs:int) as xs:string* {\r\n  (: cts:stem incurs much of the CPU load here, so first use faster cts:highlight to find a text envelope around the match :)\r\n  for $area in \r\n    if ($HIGHLIGH-OPTIMIZE) \r\n    then dist:match-area-around($text-elem, $kwd, $distance * $ASSUME-MAX-CHARS-PER-WORD) \r\n    else $text-elem\r\n  let $words := cts:tokenize(lower-case($area))[ . instance of cts:word ] ! cts:stem(.) \r\n  for $x in index-of($words, $kwd) \r\n    return  (: distance before + 1 for match word + distance after = 2*dist+1 :)\r\n      subsequence($words, $x - $distance, $distance*2+1)\r\n};\r\n\r\n(: optimization method to get a text envelope around a keyword. Restrictign area of interest avoids cts:stem of every word :)\r\ndeclare function dist:match-area-around($text-elem as element(), $kwd as xs:string, $chars-before-and-after as xs:int) as element(area)* {\r\n  let $n := $chars-before-and-after\r\n  let $word-q := cts:word-query($kwd, (\"case-insensitive\", \"punctuation-insensitive\"))\r\n  let $match-areas := cts:highlight($text-elem, $word-q, <area>{substring($text-elem/text(), $cts:start - $n, 2*$n)}</area>)\r\n  return $match-areas/area\r\n  };\r\n\r\n(: TODO - THIS IS CUSTOM FOR EACH DATA SET - harcoded for health topics now :)\r\ndeclare function dist:text-elems($ht as element(health-topic)) as element()* {\r\n  let $summary := $ht/full-summary\r\n  (: let $orgs := $ht/site/organization\r\n  let $site-titles := for $t in $ht/site/@title/string() return <title>{$t}</title> :)\r\n  return ($summary)\r\n};\r\n\r\n(: return the top $n map keys, based on a numeric value associated with each key in the map :)\r\ndeclare function dist:top-n($m as map:map, $n as xs:int) as element(word)* {\r\n (for $k in map:keys($m)\r\n  let $val := map:get($m, $k)\r\n  order by $val descending\r\n  return <word freq=\"{$val}\">{$k}</word>\r\n  )[1 to $n]\r\n};\r\n\r\n(: find all words within $dist words of $kwd within the provided elements :)\r\ndeclare function dist:words-around($text-elems as element()*, $kwd as xs:string*, $dist as xs:int*, $max as xs:int*) {\r\n  (: let $log := xdmp:log(text{\"in words-around. expect w a priv shortly\"}) :)\r\n  let $update-stops := map:put($stops, $kwd, true()) (: consider $kwd a stop word so we do not return it :)\r\n  return \"WORDS AROUND STUB\"\r\n  (:  xx\r\n  let $freq-map := map:map()\r\n  let $do-map-update := \r\n    for $te in $text-elems\r\n      let $words := dist:words-around-private($te, $kwd, 3) \r\n      let $log := xdmp:log(text{\"w a priv: \", $words})\r\n      for $w in $words\r\n        let $old-count := map:get($freq-map, $w)\r\n        where not(map:get($stops, $w))\r\n        return map:put($freq-map, $w, if ($old-count) then $old-count + 1 else 1)\r\n  let $log := xdmp:log(text{\"freq map keys\", map:keys($freq-map)})\r\n  return dist:top-n($freq-map, $max) \r\n  xx :)\r\n};\r\n\r\nlet $kwd := \"family\"\r\nfor $ht in cts:search(//health-topic, $kwd, \"score-random\")[1 to 2000]\r\nlet $text-elems := dist:text-elems($ht)\r\nlet $log := xdmp:log(text{\"num text elems=\", count($text-elems)})\r\nlet $log := xdmp:log(text{\"calling dist:words-around(\",$text-elems,\":\", $kwd, \":4:7\"})\r\nreturn dist:words-around($text-elems, $kwd, 4, 7) \r\n", "sampledata":"", "version":"6.0-1", "tofixin":"6.0-4", "fixedin":"6.0-4", "platform":"all", "memory":"", "processors":"", "note":"Also tested on a 6.0-2 nightly demo server", "subscribers":[{"username":"dfeldman", "name":"Damon Feldman", "email":"dfeldman@marklogic.com"}, {"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, {"username":"rpolasani", "name":"Raghu Polasani", "email":"raghu.polasani@marklogic.com"}], "attachments":[], "relationships":[{"type":"", "to":""}], "clones":[], "cloneOf":"", "support":{"headline":"A cts:search() call inside a FLWOR expression occasionally misses values", "supportDescription":"A cts:search() call inside a FLWOR expression occasionally misses values. In particular this can happen when the cts:search() occurs in a for clause, has a preceding let clause in the same FLWOR, and the return is a function call.", "publishStatus":"Publish", "tickets":[], "customerImpact":{"level":"N/A", "title":""}, "workaround":""}, "tags":["XQuery", "dfeldman"], "changeHistory":[{"time":"2013-01-10T13:22:05.489886-08:00", "updatedBy":{"username":"dfeldman", "name":"Damon Feldman", "email":"dfeldman@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"As a workaround:\r\n\r\nchanging to a let, then a for works:\r\n\r\nlet $ht-seq := cts:search(//health-topic, $kwd, \"score-random\")[1 to 2000]\r\nfor $ht in $ht-seq\r\n[...]\r\n"}, {"time":"2013-01-10T13:22:05.746441-08:00", "updatedBy":{"username":"dfeldman", "name":"Damon Feldman", "email":"dfeldman@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"As a workaround:\r\n\r\nchanging to a let, then a for works:\r\n\r\nlet $ht-seq := cts:search(//health-topic, $kwd, \"score-random\")[1 to 2000]\r\nfor $ht in $ht-seq\r\n[...]\r\n"}, {"time":"2013-01-10T13:33:26.96341-08:00", "updatedBy":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "change":{"status":{"from":"", "to":"Verify"}, "assignTo":{"from":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "to":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}}}, "files":[], "show":true}, {"time":"2013-01-10T13:33:26.96341-08:00", "updatedBy":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "change":{"assignTo":{"from":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "to":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}}}, "files":[], "show":true}, {"time":"2013-01-10T13:33:26.96341-08:00", "updatedBy":{"username":"cjl", "name":"Christopher Lindblad", "email":"cjl@cerisent.com"}, "change":{"tofixin":{"from":"", "to":"6.0-3"}}, "files":[], "show":true}, {"time":"2013-01-25T05:05:00.678208-08:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"Possibly another instance of this bug, from the mailing list:\r\n\r\ncount(collection()[*][1]),\r\ncount(\r\n  for $doc in collection()[*][1]\r\n  return $doc),\r\ncount(\r\n  for $doc in (collection()[*])[1]\r\n  return $doc),\r\ncount(\r\n  for $doc in collection()[1]\r\n  return $doc),\r\ncount(\r\n  let $seq := collection()[*][1]\r\n  for $doc in $seq\r\n  return $doc)\r\n=>\r\n1\r\n10604\r\n10604\r\n1\r\n1"}, {"time":"2013-02-28T11:57:05.414609-08:00", "updatedBy":{"username":"rhu", "name":"Ron Hu", "email":"ron.hu@marklogic.com"}, "change":{"tofixin":{"from":"6.0-3", "to":"6.0-4"}}, "files":[], "show":true}, {"time":"2013-03-01T03:52:37.925803-08:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"I think we should fix this in 6.0-3 - it results in bad query results for unexplainable reasons."}, {"time":"2013-03-01T03:52:37.925803-08:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{"tofixin":{"from":"6.0-4", "to":"6.0-3"}}, "files":[], "show":true}, {"time":"2013-03-01T13:20:18.348767-08:00", "updatedBy":{"username":"dgorbet", "name":"David Gorbet", "email":"David.Gorbet@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"Ok to fix in 6.0-3."}, {"time":"2013-03-22T16:03:10.520755-07:00", "updatedBy":{"username":"rhu", "name":"Ron Hu", "email":"ron.hu@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"John is too busy to fix it in 6.0-3 time frame.  Push to 6.0-4."}, {"time":"2013-03-22T16:03:10.520755-07:00", "updatedBy":{"username":"rhu", "name":"Ron Hu", "email":"ron.hu@marklogic.com"}, "change":{"tofixin":{"from":"6.0-3", "to":"6.0-4"}}, "files":[], "show":true}, {"time":"2013-06-18T02:14:14.29888-07:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{}, "files":[], "show":true, "svn":{"repository":"/project/engsvn", "revision":"144562", "paths":["xdmp/branches/b6_0/src/ValueInference.cpp", "xdmp/branches/b6_0/src/XQuery.cpp", "xdmp/branches/b6_0/src/XQuery.h"], "affectedBugs":[]}, "comment":"bug:20427 Fixed evaluation of tail calls in FLWOR expressions"}, {"time":"2013-06-18T02:40:58.291246-07:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{}, "files":[], "show":true, "comment":"Here's a small test case for this bug:\r\n\r\nxquery version \"1.0-ml\";\r\nxdmp:document-insert(\"/foo1.xml\", <foo>all in the family</foo>),\r\nxdmp:document-insert(\"/foo2.xml\", <foo>influenza can be transmitted in a family</foo>),\r\nxdmp:document-insert(\"/foo3.xml\", <foo>family thereapy may be appropriate</foo>),\r\nxdmp:document-insert(\"/foo4.xml\", <foo>discuss this issue with your family soon</foo>)\r\n;\r\ndeclare function local:words-around()\r\n{\r\n  xdmp:log(\"result\"),\"result\"\r\n};\r\n \r\nlet $kwd := \"family\"\r\nfor $ht in cts:search(/foo,$kwd)\r\nreturn local:words-around()\r\n"}, {"time":"2013-07-01T06:09:32.739253-07:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{}, "files":[], "show":true, "svn":{"repository":"/project/engsvn", "revision":"145464", "paths":["xdmp/trunk/src/XQuery.h", "xdmp/trunk/src/XQuery.cpp", "xdmp/trunk/src/ValueInference.cpp"], "affectedBugs":[]}, "comment":"bug:20427 Fixed evaluation of tail calls in FLWOR expressions"}, {"time":"2013-07-01T06:14:15.434851-07:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{"status":{"from":"", "to":"Test"}, "assignTo":{"from":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "to":{"username":"rpolasani", "name":"Raghu Polasani", "email":"raghu.polasani@marklogic.com"}}}, "files":[], "show":true, "comment":"Fixed."}, {"time":"2013-07-01T06:14:15.434851-07:00", "updatedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "change":{"assignTo":{"from":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "to":{"username":"rpolasani", "name":"Raghu Polasani", "email":"raghu.polasani@marklogic.com"}}}, "files":[], "show":true}, {"time":"2013-07-13T11:26:29.045278-07:00", "updatedBy":{"username":"rpolasani", "name":"Raghu Polasani", "email":"raghu.polasani@marklogic.com"}, "change":{"assignTo":{"from":{"username":"rpolasani", "name":"Raghu Polasani", "email":"raghu.polasani@marklogic.com"}, "to":{"username":"skottam", "name":"Sravan Kottam", "email":"Sravan.Kottam@marklogic.com"}}}, "files":[], "show":true}, {"time":"2013-07-18T15:02:55.241632-07:00", "updatedBy":{"username":"skottam", "name":"Sravan Kottam", "email":"Sravan.Kottam@marklogic.com"}, "change":{"status":{"from":"", "to":"Ship"}, "assignTo":{"from":{"username":"skottam", "name":"Sravan Kottam", "email":"Sravan.Kottam@marklogic.com"}, "to":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}}}, "files":[], "show":true, "comment":"verified on the build 6.0-20130718 and added the test to regression."}, {"time":"2013-08-12T18:05:53.485323-07:00", "updatedBy":{"username":"rpelton", "name":"Rick Pelton", "email":"rick.pelton@marklogic.com"}, "change":{"status":{"from":"", "to":"Closed"}, "assignTo":{"from":{"username":"rpelton", "name":"Rick Pelton", "email":"rick.pelton@marklogic.com"}, "to":{"username":"nobody", "name":"nobody nobody", "email":"nobody@marklogic.com"}}}, "files":[], "show":true}], "updatedAt":"2013-08-12T18:05:53.485323-07:00", "fixedAt":"2013-07-01T06:14:15.434851-07:00", "fixedBy":{"username":"jsnelson", "name":"John Snelson", "email":"jsnelson@marklogic.com"}, "shippedAt":"2013-07-18T15:02:55.241632-07:00", "shippedBy":{"username":"skottam", "name":"Sravan Kottam", "email":"Sravan.Kottam@marklogic.com"}, "closedAt":"2013-08-12T18:05:53.485323-07:00", "closedBy":{"username":"rpelton", "name":"Rick Pelton", "email":"rick.pelton@marklogic.com"}, "renderDescriptionAs":"normal", "renderSampleQueryAs":"normal"}