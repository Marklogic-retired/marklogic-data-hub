This example project is intended for use while developing Data Hub itself. 

# How to install

To install via Gradle, first initialize the project (include -Ptesting=true if you are trying to use a snapshot version of DHF):

    ./gradlew hubInit
    
Then modify the gradle-local.properties file and either un-comment the mlUsername and mlPassword properties and set the
password for your admin user, or set the properties to a different MarkLogic user that is able to deploy applications. 

Then deploy the application (include -Ptesting=true if you are trying to use a snapshot version of DHF):

    ./gradlew -i mlDeploy

To verify that the application is installed, visit http://localhost:8011 in your web browser and authenticate as one of
the users defined in the gradle.properties file in this project. If the application was successfully installed, you'll
see a "MarkLogic REST Server" page.

## Deploying resources as a data-hub-developer user 

A user with the data-hub-developer role is permitted to deploy the project to DHS. Update the mlUsername and mlPassword
in gradle-dhs.properties file in this project.

Then deploy the application (the "-i" is for info-level logging, which is helpful to see in case anything goes wrong):

    ./gradlew -i -PenvironmentName=dhs hubDeployAsDeveloper
 

## Authenticating 

This project defines several users in ./src/main/ml-config/security/users that can be used for development and testing. 

# Features

The sections below describe some of the features demonstrated by this project.

## Custom configuration paths

This project customizes mlConfigPaths in gradle.properties so that a 3rd configuration directory is used for user-specific 
MarkLogic configuration files:

    mlConfigPaths=src/main/hub-internal-config,src/main/ml-config,src/main/user-config

The first two paths contain files written by DHF when the Gradle "hubInit" task is run. While it is possible to add new files to 
either directory, it can be confusing to tell which files were generated by DHF and which are user-controlled files. Adding a third
configuration path - which can be any path with any directory name - eliminates this confusion. And in this scenario, a database file 
exists in the "user-config" path that adds indexes to the staging database without modifying the staging database file under hub-internal-config.
## Mapping Parameters

The mapping step defined by ./steps/mapping/mapCustomersJSON.step.json uses a feature introduced in DHF 5.5 
that allows for a user to define custom mapping parameters for use in mapping expressions. Once defined, these 
parameters can be referenced via the "$" symbol in mapping expressions. In addition, because this feature is called once
for each batch of documents processed by a mapping step, looking up values from indexes is often much faster via this 
technique versus performing a query for every document via a custom mapping function. 

This feature is enabled by first defining a property in the step configuration that points to a mapping 
parameters module:

    "mappingParametersModulePath": "/custom-modules/mapping-params/example-mapping-params.sjs"

The module can be in any directory. The only requirement is that the user running a mapping must have read and 
execute permission on the module. 

The module then defines two functions:

1. getParameterDefinitions receives the mapping step configuration and must return an array of objects, where each
object has a unique "name" property and an optional "description" property. This function is called when the mapping step
is loaded or saved in MarkLogic.
1. getParameterValues is called each time the mapping step processes a batch of documents, which includes when the "Test" button 
is used in the Hub Central mapping editor. This function receives a sequence of content objects that encapsulate the documents
being processed. It must return a JSON object whose keys match the parameter "names" defined by getParameterDefinitions. 

Typically, the value of each key in the JSON object returned by getParameterValues will be an object itself and will represent some 
mapping between keys and values. In this example project, the getParameterValues function uses the content sequence to construct a mapping of
zip codes and geospatial points via index queries. Because the getParameterValues function receives the entire batch of content objects being 
processed, it can typically perform one query to lookup data, as opposed to being called via a custom mapping function for every content object 
being processed. 

In this example, the getParameterValues function defines a "ZIP_POINTS" parameter that can then be referenced via the "$" symbol in a mapping expression. 
To facilitate looking up values in a JSON object, the DHF mapper includes a "lookup" function that looks up the value of a key for a JSON object. The 
mapCustomersJSON step uses this function and the ZIP_POINTS parameter in the following manner:

```
"geoPoint": {
  "sourcedFrom": "lookup(substring(Postal, 1, 5), $ZIP_POINTS)"
}
```

The above expression first selects the first 5 characters of the "Postal" property in a source document, and then uses that string to find an associated value 
in the ZIP_POINTS parameter, which is a map of zip codes to geospatial points. 

## Testing support

This project demonstrates how developers can test their DHF applications via [JUnit5](https://junit.org/junit5/), 
[marklogic-unit-test](https://github.com/marklogic-community/marklogic-unit-test), and the new marklogic-data-hub-junit5
library available in the DHF 5.5.0 release. This support is enabled via the following configuration in this project's 
build.gradle file:

- The "java" plugin is applied so that Gradle's support for compiling and running JUnit5 tests can be used
- In the "repositories" block, mavenCentral() and jcenter() are both included to satisfy the dependencies for test support
- In the "dependencies" block, marklogic-unit-test-modules is included so that the modules associated with this library will be 
loaded into the modules database, and marklogic-data-hub-junit5 is included to support JUnit5 testing
- The "test" block includes "useJUnitPlatform()" to tell Gradle to use the platform support in JUnit5

### marklogic-unit-test examples

Examples of marklogic-unit-test test modules can be found in the src/test/ml-modules directory. This directory is 
included in the list of directories from which to load modules via the mlModulePaths property in gradle.properties:

    mlModulePaths=src/main/ml-modules,src/test/ml-modules

This property can then be overridden in an environment where it is not desirable for test modules to be loaded. 

The mapping-test suite in the src/test/ml-modules provides an example of how to run a step in a test without depending 
on persisted data and without persisting the results of the step. This is often a useful technique for quickly verifying the 
configuration of a step and the content that it produces. 

The DHF hubGenerateTestSuite Gradle task can be used to quickly generate new test suites as well:

    ./gradlew hubGenerateTestSuite -PsuiteName=myNewSuite

This task will create new files for the test suite and print the location to which each file was written. 

Before running the above task, you may want to first run the Gradle task mlWatch in a separate window so that as soon as your 
files are created or modified, they will be immediately loaded into your modules database:

    ./gradlew -i mlWatch

You can also access the marklogic-unit-test web-based test runner by going to e.g. http://localhost:8011/test/default.xqy, 
replacing "localhost" with the correct hostname of your MarkLogic server.

### JUnit examples

The following JUnit tests are then included to demonstrate the support for JUnit 5 and marklogic-unit-test; these are all found in the 
src/test/java directory:

- org/example/RunCustomerFlowTest shows how to run a flow and verify the results by extending a base class provided by marklogic-data-hub-junit5
- org/example/CustomRunCustomerFlowTest shows how to run a flow and verify the results without extending the base class 
provided by marklogic-data-hub-junit5
- org/example/RunMarkLogicUnitTestsTest shows how to run each marklogic-unit-test module as a separate JUnit test 

After this project is deployed, the above tests can be run by Gradle via the following command:

    ./gradlew test 

The "test" task should succeed and write a report to the build/reports/test/index.html file, which you can view in a web
browser to see the results of the tests (the report generation is controlled by the Gradle Java plugin). 

You can also run just the marklogic-unit-test modules by accessing http://localhost:8011/test/default.xqy , which will display
the marklogic-unit-tet GUI for running tests. 
