plugins {
    id 'net.saliman.properties'
    id 'java'
    id 'java-test-fixtures'
    id 'maven-publish'
    id 'com.jfrog.bintray' version '1.7.2'
    id 'com.marklogic.ml-gradle' version '4.1.0'
    id "com.github.node-gradle.node" version "2.2.4"
    id 'org.springframework.boot' version '2.1.15.RELEASE'
    id "io.spring.dependency-management" version "1.0.7.RELEASE"
    id 'com.marklogic.ml-development-tools' version '5.3.0'

    // Declaring this at each subproject level, as declaring it at root level resulted in an error about the plugin
    // not being able to resolve its "dataFiles" configuration
    id "io.snyk.gradle.plugin.snykplugin" version "0.4"
}

// Disabling javadoc warnings, as we have hundreds of them, and until we want to do something about them,
// seeing them when running a Gradle task (like publishToMavenLocal) is just useless noise
javadoc.options.addStringOption('Xdoclint:none', '-quiet')

// See https://github.com/snyk/gradle-plugin for docs
snyk {
    severity = 'medium'
    api = snykToken
    autoDownload = true
    autoUpdate = true
}

repositories {
    jcenter()
    maven { url 'https://repo.spring.io/milestone' }
    maven { url 'https://developer.marklogic.com/maven2/' }

    // Needed for marklogic-junit
    maven { url 'https://dl.bintray.com/marklogic-community/Maven/' }
}

group = 'com.marklogic'

sourceCompatibility = "9"
targetCompatibility = "9"

ext {
    // Something changed with 5.5.0 such that "test --tests" doesn't work with Gradle 6.2 or 6.5
    junitPlatformVersion = '1.4.2'
    junitJupiterVersion  = '5.4.2'

    dataServicesGroup = "Data Services"
    dataServicesPath = "src/main/resources/ml-modules/root/data-hub/5/data-services"

    thirdPartySourcePath = "src/main/resources/ml-modules/root/data-hub/third-party"
}

// This enables including a logging jar in the application artifacts produced by this project - the installer and the client jars
// without that jar ending up in the library artifact.
configurations {
    datahubLogging
}

dependencies {
    // Forcing use of 1.3.71 - which is what OkHttp 4.7.2 wants, which is what Java Client 5.3 uses - so that 1.2.x
    // versions don't come onto the classpath
    compile "org.jetbrains.kotlin:kotlin-stdlib:1.3.71"
    compile "org.jetbrains.kotlin:kotlin-stdlib-common:1.3.71"

    compile(project(":marklogic-data-hub-api")) {
        // Oddly, the OkHttp 4.4.0 dependency includes version 1.2.70 and 1.3.x of these dependencies. This causes
        // class conflict errors. So they're excluded from here, and we force inclusion of 1.3.x below.
        exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib'
        exclude group: 'org.jetbrains.kotlin', module: 'kotlin-stdlib-common'
    }

    compile group: 'org.springframework.boot', name: 'spring-boot', version: '2.1.15.RELEASE'
    compile group: 'org.springframework.integration', name: 'spring-integration-http', version: '5.1.11.RELEASE'
    compile group: 'org.springframework.boot', name: 'spring-boot-autoconfigure', version: '2.1.15.RELEASE'

    compile 'com.marklogic:mlcp-util:0.9.0'
    compile 'com.marklogic:marklogic-data-movement-components:2.2.0'

    compile 'commons-io:commons-io:2.4'
    compile 'org.apache.commons:commons-text:1.1'
    datahubLogging 'ch.qos.logback:logback-classic:1.2.3'
    // For installer program
    compile "com.beust:jcommander:1.72"

    testFixturesApi(testFixtures(project(":marklogic-data-hub-api")))

    // Still need these; trying to bring them in via marklogic-data-hub-api leads to compile errors
    testCompile "org.junit.jupiter:junit-jupiter-api:${junitJupiterVersion}"
    testCompile "org.junit.jupiter:junit-jupiter-params:${junitJupiterVersion}"
    testCompile "org.junit.platform:junit-platform-commons:${junitPlatformVersion}"
    testRuntime "org.junit.jupiter:junit-jupiter-engine:${junitJupiterVersion}"

    testCompile group: 'org.springframework', name: 'spring-test', version: '5.1.16.RELEASE'

    // For managing a pool of HubConfigImpl objects
    testFixturesApi "org.apache.commons:commons-pool2:2.8.1"

    testFixturesApi 'xmlunit:xmlunit:1.3'
    testCompile 'org.skyscreamer:jsonassert:1.5.0'
    testCompile 'org.hamcrest:hamcrest-junit:2.0.0.0'
    testCompile 'org.easymock:easymock:3.4'
    testCompile 'ch.qos.logback:logback-classic:1.2.3'
    testCompile 'org.slf4j:log4j-over-slf4j:1.7.13'
    testCompile("com.marklogic:mlcp:10.0.4.2") {
      exclude group: 'org.apache.avro', module: 'avro-tools'
      exclude group: 'org.apache.commons', module: 'commons-csv'
    }

    // Provides support for invoking marklogic-unit-test tests via JUnit
    testCompile ("com.marklogic:marklogic-junit5:1.0.0") {
        // prefer the version declared above
        exclude group: 'com.marklogic', module: 'marklogic-client-api'
    }
    mlBundle "com.marklogic:marklogic-unit-test-modules:1.0.0"
}

import com.marklogic.mgmt.ManageClient
import com.marklogic.mgmt.resource.hosts.HostManager


configurations.all {
    exclude group: "org.slf4j", module: "slf4j-log4j12"
    exclude group: "log4j", module: "log4j"
}

task extractFastXmlParserZip(type: Copy) {
    doFirst {
        new File(thirdPartySourcePath).mkdirs()
    }
    description = "Extract fast-xml-parser.zip so that its files will be available when bootstrapping the test app and when building the DHF core JAR"
    from zipTree('src/main/third-party/fast-xml-parser-3.17.1.zip')
    destinationDir = new File(thirdPartySourcePath)
}

// Ensure that the fast-xml-parser files are available before any DHF jars are built
processResources.dependsOn extractFastXmlParserZip


// The Spring Boot bootJar task produces an executable jar with all dependencies that runs the DHF installer
// This jar is only meant to be used by the DHS team for installing DHF into DHS
bootJar {
    archiveClassifier = "installer"
    mainClassName = "com.marklogic.hub.dhs.installer.Main"
    from("src/main/installer") {
        include "logback.xml"
    }
    from(configurations.datahubLogging.collect { it.isDirectory() ? it : zipTree(it) }) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
    }
}

task clientJar(type: Jar) {
    description = "Build an executable jar to be used by DHF clients; as of 5.2.0, this is just for running flows"
    manifest {
        attributes "Main-Class": "com.marklogic.hub.cli.client.Main"
    }
    archiveClassifier = "client"
    from(configurations.datahubLogging.collect { it.isDirectory() ? it : zipTree(it) }) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
    }
    from(configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
    }
    exclude "spring-boot*.jar"
    from("src/main/clientJar") {
        include "logback.xml"
    }
    with jar
}
build.dependsOn clientJar

node {
  // Version of node to use.
  version = '8.10.0'

  // // Version of npm to use.
  npmVersion = '6.13.1'

  download = true
  distBaseUrl = "${nodeDistributionBaseUrl}"

  // Set the work directory for unpacking node
  workDir = file("${project.buildDir}/nodejs")

  // Set the work directory where node_modules should be located
  nodeModulesDir = file("${project.projectDir}/src/trace-ui")
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task cleanUI(type: Delete) {
  delete 'src/main/resources/ml-modules/root/trace-ui'
}

task npmInstallUI(type: NpmTask) {
    args = ['install']
    dependsOn tasks.cleanUI
}

task buildUI(type: NpmTask) {
    args = ['run', 'build.prod']
    dependsOn tasks.npmInstallUI
}

task copyUIAssets(type: Copy) {
    from 'src/trace-ui/dist'
    into 'src/main/resources/ml-modules/root/trace-ui'
    dependsOn tasks.buildUI
}

processResources {
    filesMatching("**/version.properties") {
        expand(project: project)
    }
}

task generateDataService(type: JavaExec) {
    description = "Generate DS source files based on a service name and endpoint name specified via -PserviceName and -PendpointName"
    classpath = sourceSets.test.runtimeClasspath
    main = 'com.marklogic.hub.tools.DataServiceGenerator'
    args = [
        project.hasProperty("serviceName") ? project.findProperty("serviceName") : "",
        project.hasProperty("endpointName") ? project.findProperty("endpointName") : ""
    ]
}


// Dynamically generate a task for each data-service directory, where the task can generate a Java interface for the data service
new File("src/main/resources/ml-modules/root/data-hub/5/data-services").listFiles().each { file ->
    if (file.isDirectory() && new File(file, "service.json").exists()) {
        task "generate${file.getName()}Interface"(type: com.marklogic.client.tools.gradle.EndpointProxiesGenTask, group: dataServicesGroup) {
            description = "Must run this from the ./marklogic-data-hub directory"
            serviceDeclarationFile = dataServicesPath + "/${file.getName()}/service.json"
        }
    }
}

task generateDataServiceInterfaces {
    description = "Generate Java interfaces for all Data Services. Must run this from the ./marklogic-data-hub directory"
    dependsOn {
        tasks.findAll { task -> dataServicesGroup.equals(task.group)}
    }
}

task generateSparkInterface(type: com.marklogic.client.tools.gradle.EndpointProxiesGenTask, group: dataServicesGroup) {
    description = "Must run this from the ./marklogic-data-hub directory"
    serviceDeclarationFile = "src/main/resources/ml-modules/root/marklogic-data-hub-spark-connector/service.json"
    javaBaseDirectory = "../marklogic-data-hub-spark-connector/src/main/java"
}

// When publishing the DHF core jar, or building it for release, it needs to have the compiled trace-ui files in it so
// that the trace-ui feature is available for those users that are aware of it. Otherwise, copyUIAssets is not executed as it can take a couple
// minutes to finish, and it's not typically needed during local development.
if (gradle.startParameter.taskNames*.toLowerCase().contains("publish") || gradle.startParameter.taskNames*.toLowerCase().contains("build")) {
    processResources.dependsOn copyUIAssets
}

tasks.clean.dependsOn cleanUI

jar{
    enabled = true
}

bootRun {
    enabled = false
}

javadoc {
   options.overview = 'src/main/resources/overview.html'
}

Node pomCustomizations = new NodeBuilder(). project {
    name 'marklogic-data-hub'
    packaging 'jar'
    textdescription 'Library for Creating an Operational Data Hub on MarkLogic'
    url 'https://github.com/marklogic/marklogic-data-hub'

    scm {
        url 'git@github.com:marklogic/marklogic-data-hub.git'
        connection 'scm:git@github.com:marklogic/marklogic-data-hub.git'
        developerConnection 'scm:git@github.com:marklogic/marklogic-data-hub.git'
    }

    licenses {
        license {
            name 'The Apache Software License, Version 2.0'
            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        }
    }

    developers {
        developer {
            name 'MarkLogic'
            email 'java-sig@marklogic.com'
            organization 'MarkLogic'
            organizationUrl 'https://www.marklogic.com'
        }
        developer {
            name 'MarkLogic Github Contributors'
            email 'general@developer.marklogic.com'
            organization 'Github Contributors'
            organizationUrl 'https://github.com/marklogic/marklogic-data-hub/graphs/contributors'
        }
    }
}

publishing {
    publications {
        main(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
            artifact bootJar
            artifact clientJar

            pom.withXml {
                asNode().appendNode('description', pomCustomizations.textdescription.text())
                asNode().append(pomCustomizations.developers)
                asNode().append(pomCustomizations.name)
                asNode().append(pomCustomizations.packaging)
                asNode().append(pomCustomizations.url)
                asNode().append(pomCustomizations.scm)
                asNode().append(pomCustomizations.licenses)
            }
        }
    }
    repositories {
        maven {
            if (project.hasProperty("mavenUser")) {
                credentials {
                    username mavenUser
                    password mavenPassword
                }
            }
            url publishUrl
        }
    }
}

bintray {
    user = project.hasProperty('bintrayUser') ? project.property('bintrayUser') : System.getenv('BINTRAY_USER')
    key = project.hasProperty('bintrayApiKey') ? project.property('bintrayApiKey') : System.getenv('BINTRAY_API_KEY')
    publications = ['main']
    pkg {
        repo = 'maven'
        name = project.name
        userOrg = 'marklogic'
        desc = pomCustomizations.textdescription.text()
        licenses = ['Apache-2.0']
        websiteUrl = pomCustomizations.url
        vcsUrl = pomCustomizations.scm.url
        issueTrackerUrl = 'https://github.com/marklogic/marklogic-data-hub/issues'
    }
}

ext {
    // mlAppConfig is an instance of com.marklogic.appdeployer.AppConfig
    mlAppConfig {

        moduleTokensPropertiesSources = new ArrayList<>()

        // override some default values with our values
        modulesDatabaseName = mlModulesDbName
        triggersDatabaseName = mlStagingTriggersDbName
        schemasDatabaseName = mlStagingSchemasDbName
        restPort = Integer.parseInt(mlJobPort)

        // Configure custom tokens for our json files
        customTokens.put("%%mlStagingAppserverName%%", mlStagingAppserverName)
        customTokens.put("%%mlStagingPort%%", mlStagingPort)
        customTokens.put("%%mlStagingDbName%%", mlStagingDbName)

        customTokens.put("%%mlFinalAppserverName%%", mlFinalAppserverName)
        customTokens.put("%%mlFinalPort%%", mlFinalPort)
        customTokens.put("%%mlFinalDbName%%", mlFinalDbName)

        customTokens.put("%%mlJobAppserverName%%", mlJobAppserverName)
        customTokens.put("%%mlJobPort%%", mlJobPort)
        customTokens.put("%%mlJobDbName%%", mlJobDbName)

        customTokens.put("%%mlModulesDbName%%", mlModulesDbName)
        customTokens.put("%%mlStagingTriggersDbName%%", mlStagingTriggersDbName)
        customTokens.put("%%mlStagingSchemasDbName%%", mlStagingSchemasDbName)

        modulePaths = [
            new File(getProjectDir(), "src/main/resources/ml-modules").getAbsolutePath(),
            new File(getProjectDir(), "src/test/ml-modules").getAbsolutePath()
        ]
    }
}

def propFile = file("gradle.properties")
boolean sslRun = Boolean.parseBoolean(System.properties['ssl'])
boolean certAuth = Boolean.parseBoolean(System.properties['certauth'])
def props = new Properties()
propFile.withInputStream { props.load(it) }

task bootstrap(type: JavaExec) {
    classpath = sourceSets.test.runtimeClasspath
    main = 'com.marklogic.bootstrap.TestAppInstaller'
    systemProperty "mlHost", mlHost
}

test {
    systemProperty "mlHost", mlHost
    useJUnitPlatform()
    minHeapSize = "128m"
    maxHeapSize = "256m"
    exclude 'com/marklogic/bootstrap/**'
    classpath = project.sourceSets.test.runtimeClasspath
}

task testAcceptance(type: Test) {
    systemProperty "mlHost", mlHost
    useJUnitPlatform  {
        include 'com/marklogic/hub_unit_test/RunMarkLogicUnitTestsTest*'
        include 'com/marklogic/hub/**'
        if (!(certAuth || sslRun)){
            include 'com/marklogic/hub/PiiE2E.class'
        }
    }
}

task testIntegration(type: Test) {
    systemProperty "mlHost", mlHost
    useJUnitPlatform  {
        include 'com/marklogic/hub_integration/**'
    }
}

task testBootstrap(type: Test) {
    useJUnitPlatform  {
        include 'com/marklogic/bootstrap/**'
    }
}

task testUnit(type: Test) {
    description = "Run the marklogic-unit-test tests, which also forces those modules to be loaded"
    useJUnitPlatform {
        include 'com/marklogic/hub_unit_test/RunMarkLogicUnitTestsTest*'
    }
}

task setupSSL{
    doFirst{
        def bootStrapHost = null
        if(sslRun || certAuth){
            com.marklogic.mgmt.ManageClient manageClient = new ManageClient(new com.marklogic.mgmt.ManageConfig(mlHost, 8002, mlSecurityUsername, mlSecurityPassword))
            com.marklogic.mgmt.resource.hosts.HostManager hostManager = new HostManager(manageClient)
            bootStrapHost = hostManager.getHostNames().get(0)
            if(! bootStrapHost.toLowerCase().contains("marklogic.com")){
                throw new GradleException("The test with current options will run only in marklogic.com domain")
            }

            javaexec {
                classpath = sourceSets.test.runtimeClasspath
                main = 'com.marklogic.bootstrap.SSLsetup'
                args = [mlHost, mlSecurityUsername, mlSecurityPassword, certAuth, sslRun]
                }
            }
            if(sslRun) {
                //checking if one of the property is already set
                if(props.getProperty('mlJobSimpleSsl')==null){
                    propFile.append("\n" +
                            "mlJobSimpleSsl=true\n" +
                            "mlFinalSimpleSsl=true\n" +
                            "mlAdminScheme=https\n" +
                            "mlManageScheme=https\n" +
                            "mlAppServicesSimpleSsl=true\n" +
                            "mlManageSimpleSsl=true\n" +
                            "mlStagingSimpleSsl=true")
                }
            }
            if(certAuth) {
                if(props.getProperty('mlStagingAuth')==null){
                    propFile.append("\n" +
                            "mlStagingAuth=certificate\n" +
                            "mlFinalAuth=certificate\n" +
                            "mlHost="+bootStrapHost+"\n"+
                            "mlAdminScheme=https\n" +
                            "mlManageScheme=https\n" +
                            "mlJobAuth=certificate")
            }
        }
    }
}

bootstrap.dependsOn extractFastXmlParserZip
bootstrap.finalizedBy mlPrepareBundles // ensures that marklogic-unit-test is downloaded

setupSSL.dependsOn(testClasses)
bootstrap.dependsOn(setupSSL)
task bootstrapAndTest(dependsOn:["bootstrap", "test"])
test.mustRunAfter bootstrap
testIntegration.dependsOn(bootstrap)
testAcceptance.dependsOn(bootstrap)
testBootstrap.dependsOn(bootstrap)
